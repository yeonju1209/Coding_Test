{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "5eac5b8d",
   "metadata": {},
   "source": [
    "### 1. 그룹 단어 체커"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 46,
   "id": "04373d34",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "1\n",
      "z\n",
      "1\n"
     ]
    }
   ],
   "source": [
    "cnt = 0\n",
    "n = int(input())\n",
    "for _ in range(n):\n",
    "    s = input()\n",
    "    pre = s[0]\n",
    "    s_set = set(pre)\n",
    "    for i in s[1:]:\n",
    "#         print(pre,i)\n",
    "#         print(s_set)\n",
    "        if i!=pre and i in s_set:\n",
    "#             print('그룹 단어X')\n",
    "            break\n",
    "        s_set.add(i)\n",
    "        pre = i\n",
    "    else: # break에 안걸린 경우\n",
    "        cnt += 1\n",
    "print(cnt)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "fed91520",
   "metadata": {},
   "source": [
    "### 2. 2048(Easy)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 467,
   "id": "ea1b1f94",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "3\n",
      "2 2 2\n",
      "4 4 4\n",
      "8 8 8\n",
      "16\n"
     ]
    }
   ],
   "source": [
    "from itertools import product,chain\n",
    "\n",
    "n = int(input())\n",
    "arr = [list(map(int,input().split())) for _ in range(n)]\n",
    "\n",
    "func_dict = {0:move_left, 1:move_right, 2:move_up, 3:move_down}\n",
    "max_val = 0\n",
    "\n",
    "for i in (product(range(4),repeat=5)):\n",
    "    # arr 복사 필수!!! (계속 바꿔야되니까)\n",
    "    tmp_arr = [arr[i][:] for i in range(n)]\n",
    "    for loc in i:\n",
    "        tmp_arr = func_dict[loc](tmp_arr)\n",
    "    max_val = max(max_val,max(chain(*tmp_arr)))\n",
    "print(max_val)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 413,
   "id": "cd8043e5",
   "metadata": {},
   "outputs": [],
   "source": [
    "def move_left(arr):\n",
    "    tmp_arr = [arr[i][:] for i in range(n)]\n",
    "\n",
    "    for i in range(n):\n",
    "        stack = []\n",
    "        update_list = []\n",
    "        for j in range(n):\n",
    "            p = tmp_arr[i][j]\n",
    "            if p == 0:\n",
    "                continue\n",
    "\n",
    "            stack.append(p)\n",
    "            if len(stack) >= 2 and stack[-1]==stack[-2]:\n",
    "                update_list += stack[:-2] + [stack[-1]*2]\n",
    "                stack = []\n",
    "                \n",
    "        update_list += stack\n",
    "        update_list += [0]*(n-len(update_list))\n",
    "        tmp_arr[i] = update_list\n",
    "    return tmp_arr\n",
    "\n",
    "\n",
    "def move_right(arr):\n",
    "    tmp_arr = [arr[i][:] for i in range(n)]\n",
    "\n",
    "    for i in range(n):\n",
    "        stack = []\n",
    "        update_list = []\n",
    "        for j in range(n)[::-1]:\n",
    "            p = tmp_arr[i][j]\n",
    "            if p == 0:\n",
    "                continue\n",
    "\n",
    "            stack.append(p)\n",
    "            if len(stack) >= 2 and stack[-1]==stack[-2]:\n",
    "                update_list += stack[:-2] + [stack[-1]*2]\n",
    "                stack = []\n",
    "\n",
    "        # 마지막에 뒤집어서 거꾸로 더해주면 됨\n",
    "        update_list += stack\n",
    "        update_list = [0]*(n-len(update_list)) + update_list[::-1]\n",
    "        tmp_arr[i] = update_list\n",
    "    return tmp_arr\n",
    "\n",
    "\n",
    "def move_up(arr):\n",
    "    tmp_arr = [arr[i][:] for i in range(n)]\n",
    "\n",
    "    for i in range(n): # 열\n",
    "        stack = []\n",
    "        update_list = []\n",
    "        for j in range(n): # 행\n",
    "            p = tmp_arr[j][i]\n",
    "            if p == 0:\n",
    "                continue\n",
    "            \n",
    "            stack.append(p)\n",
    "            if len(stack) >= 2 and stack[-1]==stack[-2]:\n",
    "                update_list += stack[:-2] + [stack[-1]*2]\n",
    "                stack = []\n",
    "\n",
    "        update_list += stack\n",
    "        update_list += [0]*(n-len(update_list))\n",
    "        \n",
    "        # 업데이트 과정\n",
    "        for j in range(n):\n",
    "            tmp_arr[j][i] = update_list[j]\n",
    "    return tmp_arr\n",
    "\n",
    "\n",
    "def move_down(arr):\n",
    "    tmp_arr = [arr[i][:] for i in range(n)]\n",
    "\n",
    "    for i in range(n): # 열\n",
    "        stack = []\n",
    "        update_list = []\n",
    "        for j in range(n)[::-1]: # 행\n",
    "            p = tmp_arr[j][i]\n",
    "            if p == 0:\n",
    "                continue\n",
    "            \n",
    "            stack.append(p)\n",
    "            if len(stack) >= 2 and stack[-1]==stack[-2]:\n",
    "                update_list += stack[:-2] + [stack[-1]*2]\n",
    "                stack = []\n",
    "\n",
    "        update_list += stack\n",
    "        update_list = [0]*(n-len(update_list)) + update_list[::-1]\n",
    "        \n",
    "        for j in range(n):\n",
    "            tmp_arr[j][i] = update_list[j]\n",
    "    return tmp_arr"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "3f5c7627",
   "metadata": {},
   "source": [
    "### 3. 사다리 조작\n",
    "- i번 세로선의 결과가 i번이 나와야 함"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "45218667",
   "metadata": {},
   "outputs": [],
   "source": [
    "def play_game():\n",
    "    for start_c in range(N - 1):\n",
    "        now_r, now_c = 0, start_c\n",
    "        while now_r < H:\n",
    "            if visited[now_r][now_c] == 1:\n",
    "                if (now_r, now_c) in ladders:\n",
    "                    now_c += 1\n",
    "                else:\n",
    "                    now_c -= 1\n",
    "            now_r += 1\n",
    "        if now_c != start_c:\n",
    "            return False\n",
    "    return True\n",
    "\n",
    "\n",
    "def set_ladder(start_r, d):\n",
    "    global min_horizon_cnt\n",
    "    if d > 3:\n",
    "        return\n",
    "    else:\n",
    "        for r in range(start_r, H):\n",
    "            for c in range(N - 1):\n",
    "                if visited[r][c] == 0 and visited[r][c + 1] == 0:\n",
    "                    visited[r][c], visited[r][c + 1] = 1, 1\n",
    "                    ladders.append((r, c))\n",
    "\n",
    "                    if play_game():\n",
    "                        if min_horizon_cnt == -1:\n",
    "                            min_horizon_cnt = d\n",
    "                        else:\n",
    "                            min_horizon_cnt = min(min_horizon_cnt, d)\n",
    "                    else:\n",
    "                        set_ladder(r, d + 1)\n",
    "                    visited[r][c], visited[r][c + 1] = 0, 0\n",
    "\n",
    "                    ladders.pop()\n",
    "\n",
    "\n",
    "N, M, H = map(int, input().split())\n",
    "visited = [[0 for _ in range(N)] for _ in range(H)]\n",
    "ladders = []\n",
    "for _ in range(M):\n",
    "    a, b = map(int, input().split())\n",
    "    visited[a - 1][b - 1], visited[a - 1][b] = 1, 1\n",
    "    ladders.append((a - 1, b - 1))\n",
    "min_horizon_cnt = -1\n",
    "\n",
    "if M == 0:\n",
    "    min_horizon_cnt = 0\n",
    "elif M == 1:\n",
    "    min_horizon_cnt = 1\n",
    "else:\n",
    "    if play_game():\n",
    "        min_horizon_cnt = 0\n",
    "    else:\n",
    "        set_ladder(0, 1)\n",
    "\n",
    "print(min_horizon_cnt)"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.12"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
